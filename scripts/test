#!/usr/bin/env ruby
# frozen_string_literal: true

require 'bundler'
require 'fileutils'
require 'pathname'

# path to your application root.
APP_ROOT = Pathname.new(File.expand_path('..', __dir__))

# Set up environment
ENV['RAILS_ENV'] ||= 'test'
ENV['COVERAGE'] ||= 'true'
ENV['CI'] ||= nil
ENV['SPEC_OPTS'] ||= "--format Fuubar --color #{(ENV['CI'] ? '--format RspecJunitFormatter --out rspec.xml' : '')}"
ENV['COVERAGE_DIR'] ||= APP_ROOT.join('coverage').to_s

# Set up coloring
def red(msg)
  "\033[0;31m#{msg}\033[0m"
end

def green(msg)
  "\033[0;32m#{msg}\033[0m"
end

def yellow(msg)
  "\033[0;33m#{msg}\033[0m"
end

def bundle!
  system('bundle check') || system!('bundle install -j2')
end

def runner(dir:, name:)
  FileUtils.chdir dir do
    puts yellow("--- Preparing test for #{name} ---")
    bundle!
    code = true
    if File.directory?('spec')
      puts yellow("--- Running specs for #{name} ---")
      code &= system('bin/rspec')
    end

    puts red("--- FAILED for #{name} ---") unless code
    @results[name] = code
  end

  return unless File.exist?(APP_ROOT.join(dir, 'reports'))

  report_dir = APP_ROOT.join('reports', name)
  FileUtils.mkdir_p report_dir unless File.directory?(report_dir)

  FileUtils.cp_r Dir[APP_ROOT.join(dir, 'reports', '*')], report_dir, verbose: true
end

def system!(*args)
  system(*args) || abort("\n== Command #{args} failed ==")
end

def run(*args, message:)
  puts "== #{message} =="
  system!(*args)
end

ENGINES = Dir[APP_ROOT.join('engines', '*')].select { |d| File.directory?(d) }.collect { |d| File.basename(d) }
LIBRARIES = Dir[APP_ROOT.join('lib', '*', '*.gemspec')].collect { |d| File.basename(File.dirname(d)) }

# Set up test suite
@results = {}

puts '     Backend Test Suite'
puts '============================'
puts " Environment: #{ENV['RAILS_ENV']}"
puts "    Coverage: #{ENV['COVERAGE']}"
puts "          CI: #{ENV['CI']}"
puts "Spec Options: #{ENV['SPEC_OPTS']}"
puts "Coverage Dir: #{ENV['COVERAGE_DIR']}"

puts yellow('*** Preparing test environment ***')
bundle!

# Always ensure we have clean database
tasks = {
  'test database' => 'RAILS_ENV=development bin/rails db:test:prepare'
}

tasks.each do |label, cmd|
  system(cmd) || raise(red(label))
end

puts yellow('*** Running Engine tests ***')

# Run tests for each engine, in random order
ENGINES.shuffle.each do |engine|
  runner(dir: APP_ROOT.join('engines', engine), name: engine)
end

LIBRARIES.shuffle.each do |engine|
  runner(dir: APP_ROOT.join('lib', engine), name: engine)
end

runner(dir: APP_ROOT, name: 'api')

# Load Simplecov
@simplecov = begin
               require 'simplecov'
               SimpleCov.configure { merge_timeout 3600 }
               SimpleCov::ResultMerger.results.map { |r| [r.command_name, r.covered_percent] }.to_h
             rescue LoadError
               {}
             end

field_length = (ENGINES + LIBRARIES + %w(api)).map(&:length).max

puts '=' * (field_length + 45)
@results.each do |name, result|
  coverage = @simplecov.fetch(name, 0.0).round(1)

  puts format(
    "%<name>#{field_length}s: %<result>7s (Coverage %<percent>5s %%)",
    name: name,
    result: (result ? green('SUCCESS') : red('FAILED')),
    percent: coverage
  )
end
puts '=' * (field_length + 45)

if @results.values.reduce(:&)
  puts green('*** TEST PASSED ***')
  exit(0)
else
  puts red('*** TEST FAILED ***')
  exit(1)
end
